ASP.NET
Active Server Pages
Фреймворк .NET призначений для веб-проєктів

Клієнт-серверна технологія
	це технологія, за якою в інформаційному обміні беруть участь две програми:
	клієнт - той, хто надсилає запит
	сервер - той, зто очікує, приймає та оброблює запит
	у даному сенсі клієнт та сервер - це ролі, що їх гра.ть програми.

Веб-проєкт:
a)
	Сервер (сховище)				    	Клієнт (браузер)
	 HTML + CSS + JS		 <---	      пише адресу у браузері
	    [file(s)]		     --->		файли приймаються і виконуються
б)
	Сервер (активний)					     Клієнт (браузер)
	 CS (Sharp)				 <---		  пише адресу у браузері
	 формує HTML			 --->		дані приймаються (і, можливо виконуються)

https://localhost:7047/ localhost - спеціальне ім'я, яке показує на данний ПК (петля)
Запит потрапляє до ASP - до маршрутизатора (визначеного у Program.cs)
    pattern: "{controller=Home}/{action=Index}/{id?}");
згідно з шаблоном, щапит розподіляється на 3 частини, відокремленні "/"
	controller / action / id
якщо якоїсь частини	немає, то береться значення за замовченням 
	базовий запит "/" -- controller = Home, action = Index, id = null

ASP формує ім'я контроллера з'єднуючи "Home" та "Controller" і шукає відповідний 
у каталозі "Controllers" - знаходить його, створює з нього об'єкт та намагається
запустити у ньому метод, який відповідає за назвою "action", тобто "Index"

Контроллер викликає View(), що означає перехід до представлення.
Воно шукається у каталозі Views|[controller]/[action].cshtml
тобто Views/Home/Index.cshtml
Якщо не знаходить, то намагається шукати к каталозі Shared 
тобто Views/Shared/Index.cshtml

Цуей файл "вставляється" до файлу-шаблону представлень
	Views/Shared_Layout.cshtml
у місце, в якому знахродиться команда
	@RenderBody()

________________________________________________________________

HTTP HyperText Transfer Protocol

Request / Response

Request:

PUT/Home/Index HTTP/1.1				\r\n			| method: GET,POST,PUT,PATCH,DELETE,  HEAD,OPTIONS,TRACE
Host: mysite.com					\r\n			| Заголовки по схемі
Connection: close					\r\n			| ключ: значення; атрибути
Accept: text/html; charset=utf-8	\r\n			| 
									\r\n			| кінець заголовків - порожній рядок
{"user":"239467923", "new-name":"Petrovich"}		| тіло - до кінця пакету (опціаналбно). Тіло заборонено для GET та HEAD


Response:

HTTP/1.1 202 Accepted								| 202 - статус-код
Connection: close									| Accepted - Reason Pharse
Content-Type: application/json						|
													|
{"server-time": 1876972345}							|


HTML Forms
методи: GET та POST
спосіб кодування даних (enctype)

  x-www-form-urlencoded: (за замовченням)
	ключ-значення ключ 2-значення 2&...
	дозволяється як GET, так і  POST. У запитах GET закодовані дані 
	додаються до URL після "?", у випадку POST - у тіло

  multipart/form-data: тільки POST дозволяє передачу файлів
	Content-Type: text/plain
	Content-Disposition: form-field; name=ключ1

	значення1
	--delimiter-----------------
	Content-Type: image/jpeg
	Content-Disposition: form-file; name=file1.jpg

	JPEG11980hvuanw98y3w3urh; kjnavp9792t4rb;kjnv
	----delimiter----------------

-----------------------------------------------------------------------

SUBMIT / AJAX

Form/submit                   Server
<form>
<submit> --------------------> Новий
</form>						   HTML
								 |
Оновлення сторінки <--------------



AJAX (Async Javascript And XML)

<input>
<input>
<button click
        JS fetch ------------> Дані 
							   XML / JSON
        Обробник JS <----------
Протягом обміну даними
сторінка не оновлюється
та зберігає інтерактивність
(відповідає на UI)

--------------------------------------------------------------------------

Кодування - переведення символів однієї абетки у символи іншої абетки
(на відміну від шифрування - без секретів)

Розрізняють символьні та транспортні кодування
Символьні - таблиці код-символ ASCII, UTF-8
Транспортні - для усунення спец. символів, що вживаються у протоколах (?/&": ...)

A          B          C
10101010  10101011  10101100
101010 101010 101110 101100       ABC -> ggY4   base64
   g     g       Y     4

1010 1010 1010 1011 1010 1100
  A   A     A   B     A    C    -> AAABAC       base16 (hex)

----------------------------------------------------------------------------

Middleware - технологія реалізації оброблення даних, що дозволяє додавати
свої обробники "в середину" до інших обробників.

Data -> Processor1 -x-> Processor2 -> ....
             \           /
              MyProcessor

			        Middleware
Request -> Server -|M|--|M|--|M|-> Controller -> Razor(View) 
Response <--    <--|1|--|2|--|3|-------      <------- HTML

Реалізується шляхом реєстрації класів Middleware у Program.cs (Use...)
Порядок реєстрації має значення, бажано свої реєструвати після вбудованих.

Традиції написання Middleware передбачають створення розширень (extensions)
Які також зводять реєстрацію до Use... форми, наприклад, реєстрація
SessionAuthMiddleware мала б виглядати як app.UseSessionAuth()

-----------------------------------------------------------------------------

Авторизація
Задача: передати на весь проєкт інформацію про авторизаційні права / ознаки
користувача.
Просте рішення: покласти до Context.Items якісь дані
 * сам факт авторизації 
    + коротко і зрозуміло
	- немає розділення за ролями / формами допуску
 * Entity user
    + передаються всі дані про користувача
	- прив'язка до Entity, зміна моделі змусить міняти код
 * Уніфікований інтерфейс
    + універсальність
	- потрібно перетворювати наявну модель за інтерфейсом

	                                    Middleware
OAuth FB --> {name, email, fbId}		 |  \  | 
DbAuth   --> {realName, userEmail, id}	 |  -  | --> {Name, Email, Sid}
OAuth GH --> {login, ghId, userName}	 |  /  | 

---------------------------------------------------------------------

API - Application Program Interface

Контролери ASP розрізняють: MVC та API
MVC - різні адреси ведуть на різні дії (actions)
  GET /Home/Index -> Index()
  GET /Home/Db    -> Db()
-----------
 Метод один (GET), адреси різні (/Home/Index, /Home/Db)
 Повертають, частіше за все, HTML (представлення)

   
API - різні методи запиту ведуть на різні дії
  GET  /api/auth  -> DoGet()
  POST /api/auth  -> DoPost()
  PUT  /api/auth  -> DoPut()
-------------
 Одна адреса (/api/auth), методи різні (GET, POST, PUT, DELETE, ...)
 Повертають дані (object / List)


              Backend
            /    |    \     
			   A P I
		 /		 |		\
      Mobile   Desktop   Web

REST - Representation State Transfer
- Сервер не "пам'ятає" історії - кожен запит як новий
  = якщо потрібна авторизація, то запит повинен мати її в собі
- Уніфікована структура запитів та відповідей
  = для усіх запитів однакові "правила", наприклад, локалізація (мова)
     передається параметром "lang" (або заголовком Locale)
  = те ж саме для відповідей, наприклад, кількість даних буде завжди
     у параметрі "count", а кількість об'єктів на одній 
	 сторінці - "per-page"
- реалізація повного переліку дій "CRUD", причому для всіх запитів
    однакові ролі методів, наприклад, POST - завжди створює, а PUT - оновлює

------------------------------------------------------------

[User]   [Carts]		[CartProducts]
Id __    Id		____    Id
...  \__ UserId		\__ CartId
         CreateDt	    ProductId
         DeleteDt	    Cnt
         CloseDt